import { Directive, ElementRef, Input, NgModule } from '@angular/core';
import { fromEvent } from 'rxjs';

const objectProto = Object.prototype;
const hasOwnProperty = objectProto.hasOwnProperty;
function defaults(object, ...sources) {
    object = Object(object);
    sources.forEach((source) => {
        if (source != null) {
            source = Object(source);
            for (const key in source) {
                if (source.hasOwnProperty(key)) {
                    const value = object[key];
                    if (value === undefined ||
                        (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
                        object[key] = source[key];
                    }
                }
            }
        }
    });
    return object;
}
function eq(value, other) {
    return value === other || (value !== value && other !== other);
}

const defaultOptions = {
    defer: false,
    onlyWords: false,
    mask: false,
};

class SplitNodes {
    constructor(textContent, el, options) {
        this.textContent = textContent;
        this.el = el;
        this.options = options;
        this.words = [];
        this.chars = [];
        this.lineWords = [];
        this.lineChars = [];
        this.wordsArray = [];
        this.nodes = [];
        this.nodeTypes = {
            ELEMENT_NODE: 1,
            ATTRIBUTE_NODE: 2,
            TEXT_NODE: 3,
            CDATA_SECTION_NODE: 4,
            ENTITY_REFERENCE_NODE: 5,
            ENTITY_NODE: 6,
            PROCESSING_INSTRUCTION_NODE: 7,
            COMMENT_NODE: 8,
            DOCUMENT_NODE: 9,
            DOCUMENT_TYPE_NODE: 10,
            DOCUMENT_FRAGMENT_NODE: 11,
            NOTATION_NODE: 12
        };
    }
    initSplitNodes() {
        this.splitNodes(this.el);
        this.initNewNodes();
        this.setLines();
        this.updateOnResize();
    }
    splitNodes(el) {
        for (let i = 0; i < el.childNodes.length; i++) {
            const node = el.childNodes[i];
            const tag = [this.nodeTypes.ELEMENT_NODE, this.nodeTypes.DOCUMENT_NODE, this.nodeTypes.DOCUMENT_FRAGMENT_NODE].indexOf(node.nodeType) !== -1;
            const text = [this.nodeTypes.TEXT_NODE, this.nodeTypes.CDATA_SECTION_NODE].indexOf(node.nodeType) !== -1;
            if (tag) {
                this.splitNodes(node);
            }
            else if (text) {
                const words = this.splitNodesIntoWords(node);
                const wordsArray = [];
                words.forEach(chars => {
                    const wordSpan = document.createElement('span');
                    wordSpan.classList.add('split-text-word');
                    wordSpan.style.display = 'inline-block';
                    wordSpan.style.textIndent = '0';
                    if (this.options.onlyWords) {
                        wordSpan.innerHTML = chars.join('');
                    }
                    else {
                        chars.forEach(char => {
                            const charSpan = document.createElement('span');
                            charSpan.classList.add('split-text-char');
                            charSpan.style.display = 'inherit';
                            charSpan.style.textIndent = '0';
                            charSpan.innerHTML = char;
                            wordSpan.appendChild(charSpan);
                            this.chars.push(charSpan);
                        });
                    }
                    wordsArray.push(wordSpan);
                    this.words.push(wordSpan);
                });
                this.wordsArray.push(wordsArray);
                this.nodes.push(node);
            }
        }
    }
    initNewNodes() {
        this.nodes.forEach((node, index) => {
            this.wordsArray[index].forEach((word, idx) => {
                let maskSpan;
                if (this.options.mask) {
                    maskSpan = document.createElement('span');
                    maskSpan.classList.add('split-text-mask');
                    maskSpan.style.display = 'inline-block';
                    maskSpan.style.overflow = 'hidden';
                    maskSpan.style.textIndent = '0';
                    maskSpan.style.verticalAlign = 'top';
                    maskSpan.appendChild(word);
                    node.parentNode.insertBefore(maskSpan, node);
                }
                else {
                    node.parentNode.insertBefore(word, node);
                }
                const spaceSpan = document.createElement('span');
                spaceSpan.classList.add('split-text-space');
                spaceSpan.style.display = 'inline';
                spaceSpan.innerHTML = ' ';
                if (this.options.mask) {
                    node.parentNode.insertBefore(spaceSpan, maskSpan.nextSibling);
                }
                else {
                    node.parentNode.insertBefore(spaceSpan, word.nextSibling);
                }
                if (idx === this.wordsArray[index].length - 1) {
                    node.remove();
                }
            });
        });
    }
    splitNodesIntoWords(word) {
        const words = word.textContent.split(' ');
        if (words[0] === '') {
            words.splice(0, 1);
        }
        if (words[words.length - 1] === '') {
            words.splice(words.length - 1, 1);
        }
        return words.map(item => item.split(''));
    }
    getLines(elements) {
        const lineElements = [];
        let line = [];
        let lineIndex = 0;
        elements.forEach((el, index) => {
            const firstElTop = elements[lineIndex].getBoundingClientRect().top;
            const lastElIndex = elements.length - 1;
            if (el.getBoundingClientRect().top === firstElTop) {
                line.push(el);
                if (index === lastElIndex) {
                    lineElements.push(line);
                }
            }
            else {
                lineElements.push(line);
                lineIndex = index;
                line = [];
                line.push(el);
            }
        });
        return lineElements;
    }
    updateOnResize() {
        fromEvent(window, 'resize')
            .subscribe(() => {
            this.setLines();
        });
    }
    setLines() {
        this.lineWords = this.getLines(this.words);
        if (!this.options.onlyWords) {
            this.lineChars = this.getLines(this.chars);
        }
    }
}

class NgGxSplitTextDirective {
    constructor(el) {
        this.el = el;
        this.options = defaultOptions;
        this.init = false;
    }
    ngOnInit() {
        this.setCurrentOptions();
        this.initSplitNodes();
    }
    ngAfterViewInit() {
        if (!this.currentOptions.defer) {
            this.initSplit();
        }
    }
    initSplit() {
        if (this.init) {
            console.warn('Warning! Text is already initialized');
            return;
        }
        this.init = true;
        this.saveSrcText();
        this.splitNodes.initSplitNodes();
    }
    saveSrcText() {
        this.srcTextContent = this.el.nativeElement.innerHTML;
    }
    get words() {
        return this.splitNodes.words;
    }
    get lineWords() {
        return this.splitNodes.lineWords;
    }
    get chars() {
        if (this.options.onlyWords) {
            console.warn('Warning! You chose only words.');
            return;
        }
        return this.splitNodes.chars;
    }
    get lineChars() {
        if (this.options.onlyWords) {
            console.warn('Warning! You chose only words.');
            return;
        }
        return this.splitNodes.lineChars;
    }
    get nativeElement() {
        return this.el.nativeElement;
    }
    get srcText() {
        return this.srcTextContent;
    }
    get isInit() {
        return this.init;
    }
    resetSplit() {
        this.nativeElement.innerHTML = this.srcText;
    }
    setCurrentOptions() {
        this.currentOptions = defaults(this.options, defaultOptions);
    }
    initSplitNodes() {
        this.splitNodes = new SplitNodes(this.el.nativeElement.textContent, this.el.nativeElement, this.currentOptions);
    }
}
NgGxSplitTextDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngGxSplitText], ngGxSplitText'
            },] }
];
NgGxSplitTextDirective.ctorParameters = () => [
    { type: ElementRef }
];
NgGxSplitTextDirective.propDecorators = {
    options: [{ type: Input, args: ['splitOptions',] }]
};

class NgGxSplitTextModule {
}
NgGxSplitTextModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgGxSplitTextDirective],
                imports: [],
                exports: [NgGxSplitTextDirective]
            },] }
];

/*
 * Public API Surface of ng-gx-split-text
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgGxSplitTextDirective, NgGxSplitTextModule, defaultOptions };
//# sourceMappingURL=ng-gx-split-text.js.map
