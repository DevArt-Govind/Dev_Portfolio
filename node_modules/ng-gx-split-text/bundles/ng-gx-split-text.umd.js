(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs')) :
    typeof define === 'function' && define.amd ? define('ng-gx-split-text', ['exports', '@angular/core', 'rxjs'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ng-gx-split-text'] = {}, global.ng.core, global.rxjs));
}(this, (function (exports, core, rxjs) { 'use strict';

    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function defaults(object) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        object = Object(object);
        sources.forEach(function (source) {
            if (source != null) {
                source = Object(source);
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        var value = object[key];
                        if (value === undefined ||
                            (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
                            object[key] = source[key];
                        }
                    }
                }
            }
        });
        return object;
    }
    function eq(value, other) {
        return value === other || (value !== value && other !== other);
    }

    var defaultOptions = {
        defer: false,
        onlyWords: false,
        mask: false,
    };

    var SplitNodes = /** @class */ (function () {
        function SplitNodes(textContent, el, options) {
            this.textContent = textContent;
            this.el = el;
            this.options = options;
            this.words = [];
            this.chars = [];
            this.lineWords = [];
            this.lineChars = [];
            this.wordsArray = [];
            this.nodes = [];
            this.nodeTypes = {
                ELEMENT_NODE: 1,
                ATTRIBUTE_NODE: 2,
                TEXT_NODE: 3,
                CDATA_SECTION_NODE: 4,
                ENTITY_REFERENCE_NODE: 5,
                ENTITY_NODE: 6,
                PROCESSING_INSTRUCTION_NODE: 7,
                COMMENT_NODE: 8,
                DOCUMENT_NODE: 9,
                DOCUMENT_TYPE_NODE: 10,
                DOCUMENT_FRAGMENT_NODE: 11,
                NOTATION_NODE: 12
            };
        }
        SplitNodes.prototype.initSplitNodes = function () {
            this.splitNodes(this.el);
            this.initNewNodes();
            this.setLines();
            this.updateOnResize();
        };
        SplitNodes.prototype.splitNodes = function (el) {
            var _this = this;
            var _loop_1 = function (i) {
                var node = el.childNodes[i];
                var tag = [this_1.nodeTypes.ELEMENT_NODE, this_1.nodeTypes.DOCUMENT_NODE, this_1.nodeTypes.DOCUMENT_FRAGMENT_NODE].indexOf(node.nodeType) !== -1;
                var text = [this_1.nodeTypes.TEXT_NODE, this_1.nodeTypes.CDATA_SECTION_NODE].indexOf(node.nodeType) !== -1;
                if (tag) {
                    this_1.splitNodes(node);
                }
                else if (text) {
                    var words = this_1.splitNodesIntoWords(node);
                    var wordsArray_1 = [];
                    words.forEach(function (chars) {
                        var wordSpan = document.createElement('span');
                        wordSpan.classList.add('split-text-word');
                        wordSpan.style.display = 'inline-block';
                        wordSpan.style.textIndent = '0';
                        if (_this.options.onlyWords) {
                            wordSpan.innerHTML = chars.join('');
                        }
                        else {
                            chars.forEach(function (char) {
                                var charSpan = document.createElement('span');
                                charSpan.classList.add('split-text-char');
                                charSpan.style.display = 'inherit';
                                charSpan.style.textIndent = '0';
                                charSpan.innerHTML = char;
                                wordSpan.appendChild(charSpan);
                                _this.chars.push(charSpan);
                            });
                        }
                        wordsArray_1.push(wordSpan);
                        _this.words.push(wordSpan);
                    });
                    this_1.wordsArray.push(wordsArray_1);
                    this_1.nodes.push(node);
                }
            };
            var this_1 = this;
            for (var i = 0; i < el.childNodes.length; i++) {
                _loop_1(i);
            }
        };
        SplitNodes.prototype.initNewNodes = function () {
            var _this = this;
            this.nodes.forEach(function (node, index) {
                _this.wordsArray[index].forEach(function (word, idx) {
                    var maskSpan;
                    if (_this.options.mask) {
                        maskSpan = document.createElement('span');
                        maskSpan.classList.add('split-text-mask');
                        maskSpan.style.display = 'inline-block';
                        maskSpan.style.overflow = 'hidden';
                        maskSpan.style.textIndent = '0';
                        maskSpan.style.verticalAlign = 'top';
                        maskSpan.appendChild(word);
                        node.parentNode.insertBefore(maskSpan, node);
                    }
                    else {
                        node.parentNode.insertBefore(word, node);
                    }
                    var spaceSpan = document.createElement('span');
                    spaceSpan.classList.add('split-text-space');
                    spaceSpan.style.display = 'inline';
                    spaceSpan.innerHTML = ' ';
                    if (_this.options.mask) {
                        node.parentNode.insertBefore(spaceSpan, maskSpan.nextSibling);
                    }
                    else {
                        node.parentNode.insertBefore(spaceSpan, word.nextSibling);
                    }
                    if (idx === _this.wordsArray[index].length - 1) {
                        node.remove();
                    }
                });
            });
        };
        SplitNodes.prototype.splitNodesIntoWords = function (word) {
            var words = word.textContent.split(' ');
            if (words[0] === '') {
                words.splice(0, 1);
            }
            if (words[words.length - 1] === '') {
                words.splice(words.length - 1, 1);
            }
            return words.map(function (item) { return item.split(''); });
        };
        SplitNodes.prototype.getLines = function (elements) {
            var lineElements = [];
            var line = [];
            var lineIndex = 0;
            elements.forEach(function (el, index) {
                var firstElTop = elements[lineIndex].getBoundingClientRect().top;
                var lastElIndex = elements.length - 1;
                if (el.getBoundingClientRect().top === firstElTop) {
                    line.push(el);
                    if (index === lastElIndex) {
                        lineElements.push(line);
                    }
                }
                else {
                    lineElements.push(line);
                    lineIndex = index;
                    line = [];
                    line.push(el);
                }
            });
            return lineElements;
        };
        SplitNodes.prototype.updateOnResize = function () {
            var _this = this;
            rxjs.fromEvent(window, 'resize')
                .subscribe(function () {
                _this.setLines();
            });
        };
        SplitNodes.prototype.setLines = function () {
            this.lineWords = this.getLines(this.words);
            if (!this.options.onlyWords) {
                this.lineChars = this.getLines(this.chars);
            }
        };
        return SplitNodes;
    }());

    var NgGxSplitTextDirective = /** @class */ (function () {
        function NgGxSplitTextDirective(el) {
            this.el = el;
            this.options = defaultOptions;
            this.init = false;
        }
        NgGxSplitTextDirective.prototype.ngOnInit = function () {
            this.setCurrentOptions();
            this.initSplitNodes();
        };
        NgGxSplitTextDirective.prototype.ngAfterViewInit = function () {
            if (!this.currentOptions.defer) {
                this.initSplit();
            }
        };
        NgGxSplitTextDirective.prototype.initSplit = function () {
            if (this.init) {
                console.warn('Warning! Text is already initialized');
                return;
            }
            this.init = true;
            this.saveSrcText();
            this.splitNodes.initSplitNodes();
        };
        NgGxSplitTextDirective.prototype.saveSrcText = function () {
            this.srcTextContent = this.el.nativeElement.innerHTML;
        };
        Object.defineProperty(NgGxSplitTextDirective.prototype, "words", {
            get: function () {
                return this.splitNodes.words;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgGxSplitTextDirective.prototype, "lineWords", {
            get: function () {
                return this.splitNodes.lineWords;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgGxSplitTextDirective.prototype, "chars", {
            get: function () {
                if (this.options.onlyWords) {
                    console.warn('Warning! You chose only words.');
                    return;
                }
                return this.splitNodes.chars;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgGxSplitTextDirective.prototype, "lineChars", {
            get: function () {
                if (this.options.onlyWords) {
                    console.warn('Warning! You chose only words.');
                    return;
                }
                return this.splitNodes.lineChars;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgGxSplitTextDirective.prototype, "nativeElement", {
            get: function () {
                return this.el.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgGxSplitTextDirective.prototype, "srcText", {
            get: function () {
                return this.srcTextContent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgGxSplitTextDirective.prototype, "isInit", {
            get: function () {
                return this.init;
            },
            enumerable: false,
            configurable: true
        });
        NgGxSplitTextDirective.prototype.resetSplit = function () {
            this.nativeElement.innerHTML = this.srcText;
        };
        NgGxSplitTextDirective.prototype.setCurrentOptions = function () {
            this.currentOptions = defaults(this.options, defaultOptions);
        };
        NgGxSplitTextDirective.prototype.initSplitNodes = function () {
            this.splitNodes = new SplitNodes(this.el.nativeElement.textContent, this.el.nativeElement, this.currentOptions);
        };
        return NgGxSplitTextDirective;
    }());
    NgGxSplitTextDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[ngGxSplitText], ngGxSplitText'
                },] }
    ];
    NgGxSplitTextDirective.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };
    NgGxSplitTextDirective.propDecorators = {
        options: [{ type: core.Input, args: ['splitOptions',] }]
    };

    var NgGxSplitTextModule = /** @class */ (function () {
        function NgGxSplitTextModule() {
        }
        return NgGxSplitTextModule;
    }());
    NgGxSplitTextModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [NgGxSplitTextDirective],
                    imports: [],
                    exports: [NgGxSplitTextDirective]
                },] }
    ];

    /*
     * Public API Surface of ng-gx-split-text
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.NgGxSplitTextDirective = NgGxSplitTextDirective;
    exports.NgGxSplitTextModule = NgGxSplitTextModule;
    exports.defaultOptions = defaultOptions;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ng-gx-split-text.umd.js.map
